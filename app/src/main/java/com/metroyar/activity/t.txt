To ensure the best practices in using Jetpack Compose and handling suspend functions for your settings, you'll want to use `LaunchedEffect` and state hoisting. In Compose, it's preferred to keep the UI state out of the composable and pass it down, typically as state or events up.

Here is an example of how you can fetch and update your DataStore preferences asynchronously with `LaunchedEffect`:

```kotlin
@Composable
fun SettingScreen(preferencesDataStore: DataStore<Preferences>) {
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()

    // A state that represents the currently saved boolean preference
    // Use produceState to automatically read from your data store when the composable enters the composition
    val initialValue = produceState(initialValue = false, preferencesDataStore) {
        preferencesDataStore.data.collect { preferences ->
            val yourBooleanKey = booleanPreferencesKey("YOUR_BOOLEAN_KEY")
            value = preferences[yourBooleanKey] ?: false
        }
    }

    Scaffold(topBar = { },
    content = { padding ->
        Column(modifier = Modifier.padding(padding)) {
            if (initialValue.value != null) { // Check if the initial value is loaded
                SettingItem(
                    title = "test",
                    initialValue = initialValue.value,
                    onSwitchClicked = { newValue ->
                        coroutineScope.launch {
                            updateDataStore(preferencesDataStore, newValue)
                        }
                    }
                )
            } else {
                // Handle loading state if needed
            }
        }
    })
}

private suspend fun updateDataStore(dataStore: DataStore<Preferences>, newValue: Boolean) {
    val yourBooleanKey = booleanPreferencesKey("YOUR_BOOLEAN_KEY")
    dataStore.edit { preferences ->
        preferences[yourBooleanKey] = newValue
    }
}
```

Here's what this code snippet does:

1. `produceState` is a composable that takes in a block for creating and observing a state object. It kickstarts a coroutine for collecting from the `DataStore` which emits values that are stored in `initialValue`.
2. In `SettingItem`, the value from `initialValue` is passed down as a parameter.
3. When the switch is clicked, it calls `onSwitchClicked` with the new value.
4. `updateDataStore` is a suspend function that takes in the new value and stores it in the `DataStore`.
5. When called, it updates the `DataStore` value inside a coroutine launched from the `SettingScreen` scope.

The key here is that all potentially long-running or asynchronous operations are performed inside coroutines, and state management is externalized from the UI elements. This follows the recommended practice for managing asynchronous data in Compose, ensuring a clear separation of concerns between data handling and UI.